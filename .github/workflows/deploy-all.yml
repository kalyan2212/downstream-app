name: Deploy All-in-One (No Pre-Set Secrets Needed)

# Complete deployment from scratch:
#   1. Login to Azure with user credentials
#   2. Bootstrap Terraform state storage (idempotent)
#   3. Terraform init + apply  ‚Üí  creates App VM + DB VM
#   4. Cloud-init on the VMs handles full app setup automatically
#   5. Health check: polls /health until HTTP 200
#
# HOW TO TRIGGER:
#   Option A (one click): Actions ‚Üí Deploy All-in-One ‚Üí Run workflow
#                         Select branch: copilot/deploy-app-to-azure
#                         Enter azure_password when prompted
#   Option B (auto):      Set repo secret AZURE_PASSWORD in repo settings
#                         Then push any commit to this branch

on:
  workflow_dispatch:
    inputs:
      azure_password:
        description: "Azure password for kbdazure@gmail.com"
        required: false
      db_password:
        description: "PostgreSQL password for the app DB user"
        required: false
        default: "DownstreamDB@2024!"
      flask_secret:
        description: "Flask secret key (any random string)"
        required: false
        default: "flask-downstream-secret-2024"
      tf_action:
        description: "Terraform action to run"
        required: true
        default: "apply"
        type: choice
        options: [apply, destroy, plan-only]
  push:
    branches: ["copilot/deploy-app-to-azure"]

jobs:
  check-secrets:
    name: Check if Azure credentials are available
    runs-on: ubuntu-latest
    permissions: {}
    outputs:
      has_creds: ${{ steps.check.outputs.has_creds }}
    steps:
      - name: Check credentials
        id: check
        run: |
          # Check workflow input first, then repo secret
          AZ_PW="${{ inputs.azure_password }}"
          if [ -z "$AZ_PW" ]; then
            AZ_PW="${{ secrets.AZURE_PASSWORD }}"
          fi
          if [ -n "$AZ_PW" ]; then
            echo "has_creds=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_creds=false" >> "$GITHUB_OUTPUT"
            echo ""
            echo "================================================================"
            echo "  No Azure credentials found. To enable auto-deploy:"
            echo "  Go to: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "  Add secret: AZURE_PASSWORD = <your Azure password>"
            echo "  OR trigger manually: Actions ‚Üí Deploy All-in-One ‚Üí Run workflow"
            echo "================================================================"
          fi

  deploy:
    name: Provision + Deploy
    needs: check-secrets
    if: needs.check-secrets.outputs.has_creds == 'true'
    runs-on: ubuntu-latest
    permissions: {}

    env:
      # Azure user email (not a secret)
      AZURE_USER: "kbdazure@gmail.com"
      TF_VAR_db_password:  ${{ inputs.db_password || 'DownstreamDB@2024!' }}
      TF_VAR_flask_secret: ${{ inputs.flask_secret || 'flask-downstream-secret-2024' }}

    steps:
      - name: Mask sensitive values
        run: |
          # Mask whichever credential source is in use
          echo "::add-mask::${{ inputs.azure_password }}"
          echo "::add-mask::${{ secrets.AZURE_PASSWORD }}"
          echo "::add-mask::${{ env.TF_VAR_db_password }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate SSH keypair for VM access
        run: |
          ssh-keygen -t ed25519 -f /tmp/deploy_key -N "" -C "downstream-deploy-${{ github.run_id }}"
          SSH_PUB=$(cat /tmp/deploy_key.pub)
          echo "TF_VAR_ssh_public_key=$SSH_PUB" >> "$GITHUB_ENV"
          echo "Generated SSH public key: $SSH_PUB"
          echo "SSH_KEY_FILE=/tmp/deploy_key" >> "$GITHUB_ENV"

      - name: Login to Azure
        run: |
          # Use workflow input if provided, else use repo secret
          AZ_PW="${{ inputs.azure_password }}"
          if [ -z "$AZ_PW" ]; then AZ_PW="${{ secrets.AZURE_PASSWORD }}"; fi
          az login -u "$AZURE_USER" -p "$AZ_PW" --allow-no-subscriptions
          SUB_ID=$(az account list --query "[0].id" -o tsv)
          SUB_NAME=$(az account list --query "[0].name" -o tsv)
          TENANT_ID=$(az account list --query "[0].tenantId" -o tsv)
          az account set --subscription "$SUB_ID"
          echo "SUB_ID=$SUB_ID"       >> "$GITHUB_ENV"
          echo "TENANT_ID=$TENANT_ID" >> "$GITHUB_ENV"
          echo "Subscription: $SUB_NAME ($SUB_ID)"

      - name: Bootstrap Terraform State Storage
        run: |
          RG="tfstate-rg"
          LOCATION="eastus"
          CONTAINER="tfstate"

          EXISTING=$(az storage account list \
            --resource-group "$RG" \
            --query "[?starts_with(name, 'tfstate')].name | [0]" \
            -o tsv 2>/dev/null || true)

          if [ -n "$EXISTING" ] && [ "$EXISTING" != "None" ]; then
            echo "Reusing existing storage account: $EXISTING"
            STORAGE_ACCOUNT="$EXISTING"
          else
            SUFFIX=$(openssl rand -hex 4)
            STORAGE_ACCOUNT="tfstate${SUFFIX}"
            echo "Creating new storage account: $STORAGE_ACCOUNT"
            az group create --name "$RG" --location "$LOCATION" --output none || true
            az storage account create \
              --name "$STORAGE_ACCOUNT" \
              --resource-group "$RG" \
              --location "$LOCATION" \
              --sku Standard_LRS \
              --min-tls-version TLS1_2 \
              --output none
            az storage container create \
              --name "$CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --output none
          fi

          echo "TF_STORAGE=$STORAGE_ACCOUNT" >> "$GITHUB_ENV"
          echo "Terraform state storage: $STORAGE_ACCOUNT"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.x"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="storage_account_name=$TF_STORAGE"

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        if: inputs.tf_action != 'plan-only' && inputs.tf_action != 'destroy'
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: inputs.tf_action == 'destroy'
        working-directory: ./terraform
        run: terraform destroy -auto-approve

      - name: Capture Outputs
        if: inputs.tf_action != 'plan-only' && inputs.tf_action != 'destroy'
        id: tf_out
        working-directory: ./terraform
        run: |
          APP_IP=$(terraform output -raw app_public_ip)
          echo "app_ip=$APP_IP" >> "$GITHUB_OUTPUT"
          echo ""
          echo "========================================================"
          echo "  App URL  : http://$APP_IP"
          echo "  Health   : http://$APP_IP/health"
          echo "  SSH      : ssh -i <downloaded_deploy_key> kalyan2212@$APP_IP"
          echo "  (Download SSH private key from workflow artifacts)"
          echo "========================================================"

      - name: Upload SSH private key as artifact
        if: inputs.tf_action != 'plan-only' && inputs.tf_action != 'destroy'
        uses: actions/upload-artifact@v4
        with:
          name: ssh-deploy-key-${{ github.run_id }}
          path: /tmp/deploy_key
          retention-days: 7

      - name: Health Check - Wait for App
        if: inputs.tf_action != 'plan-only' && inputs.tf_action != 'destroy'
        env:
          APP_IP: ${{ steps.tf_out.outputs.app_ip }}
        run: |
          echo "Waiting for http://$APP_IP/health ..."
          echo "(VM cloud-init + DB setup can take 5-10 minutes on first run)"
          MAX=48   # 48 √ó 15s = 12 minutes
          for i in $(seq 1 $MAX); do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 \
              "http://$APP_IP/health" 2>/dev/null || echo "000")
            echo "  attempt $i/$MAX  - HTTP $CODE"
            if [ "$CODE" = "200" ]; then
              echo ""
              echo "‚úÖ Health check PASSED"
              curl -s "http://$APP_IP/health"
              echo ""
              echo "üöÄ Application is live at: http://$APP_IP"
              exit 0
            fi
            sleep 15
          done
          echo "‚ùå Health check FAILED after 12 minutes"
          exit 1

